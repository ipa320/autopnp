/*
 * Copyright (c) 2011-2013, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id$
 */

/**
 * \file
 *
 * \brief  Waypoint that demarshals topic data.
 *
 * \author
 *         This file has been generated by the CHROMOSOME Modeling Tool (fortiss GmbH).
 */

/******************************************************************************/
/***   Includes                                                             ***/
/******************************************************************************/
#include "chromosomeGui/wp/marshaler/include/demarshaler.h"
#include "chromosomeGui/topic/dictionary.h"
#include "chromosomeGui/topic/dictionaryData.h"

#include "xme/hal/include/mem.h"
#include "xme/hal/include/net.h"
#include "xme/hal/include/table.h"

#include "xme/core/dataHandler/include/dataHandler.h"
#include "xme/core/topic.h"
#include "xme/core/topicData.h"

#include "xme/wp/waypoint.h"

#include <inttypes.h>

/******************************************************************************/
/***   Type definitions                                                     ***/
/******************************************************************************/
/**
 * \struct configurationItem_t
 *
 * \brief  Structure for storing waypoint configuration.
 */
typedef struct
{
	xme_core_topic_t topic; ///< Topic of the data that is stored at inputPort
	xme_core_dataManager_dataPacketId_t inputPort; ///< InputPort where topic data is stored
	xme_core_dataManager_dataPacketId_t outputPort; ///< OutputPort where marshaled data should be written to
}
configurationItem_t;

/******************************************************************************/
/***   Static variables                                                     ***/
/******************************************************************************/
/**
 * \brief  Table for storing this waypoints configurations.
 */
static XME_HAL_TABLE
(
	configurationItem_t,
	configurationTable,
	XME_WP_MARSHALER_CONFIGURATIONTABLE_SIZE
);

/**
 * \brief  Constant array that contains all topics that are supported by this
 *         marshaler.
 */
static const xme_core_topic_t
supportedTopics[] =
{
	XME_CORE_TOPIC(CHROMOSOMEGUI_TOPIC_BUTTONSIGNAL),
	XME_CORE_TOPIC(CHROMOSOMEGUI_TOPIC_WRITETEXT),
	XME_CORE_TOPIC(XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL),
	XME_CORE_TOPIC(XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL2),
	XME_CORE_TOPIC(XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL3)
};

/******************************************************************************/
/***   Prototypes                                                           ***/
/******************************************************************************/
/**
 * \brief  Performs demarshaling on the given data.
 *
 * \param  topic      Topic of the data stored at inputPort.
 * \param  inputPort  The inputPort where the marshaled data is stored.
 * \param  outputPort The outputPort where the demarshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_UNSUPPORTED if the given topic is not supported by this marshaler.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshaling
(
	xme_core_topic_t topic,
	xme_core_dataManager_dataPacketId_t inputPort,
	xme_core_dataManager_dataPacketId_t outputPort
);

/**
 * \brief  Performs demarshaling for topic 'ButtonSignal'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForButtonSignal
(
	xme_core_dataManager_dataPacketId_t inputPort,
	chromosomeGui_topic_ButtonSignal_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'WriteText'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForWriteText
(
	xme_core_dataManager_dataPacketId_t inputPort,
	chromosomeGui_topic_WriteText_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'pnpManager_runtime_graph_model'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForPnpManager_runtime_graph_model
(
	xme_core_dataManager_dataPacketId_t inputPort,
	xme_core_topic_pnpManager_runtime_graph_model_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'pnpManager_runtime_graph_model2'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForPnpManager_runtime_graph_model2
(
	xme_core_dataManager_dataPacketId_t inputPort,
	xme_core_topic_pnpManager_runtime_graph_model2_t* topicData
);
/**
 * \brief  Performs demarshaling for topic 'pnpManager_runtime_graph_model3'.
 *
 * \param  inputPort Input port where marshaled data is stored.
 * \param  topicData Buffer where marshaled data will be written to.
 *
 * \retval XME_STATUS_SUCCESS if the data was marshaled successfully.
 * \retval XME_STATUS_INTERNAL_ERROR if an error occurred during reading from the inputPort.
 */
xme_status_t
doDemarshalingForPnpManager_runtime_graph_model3
(
	xme_core_dataManager_dataPacketId_t inputPort,
	xme_core_topic_pnpManager_runtime_graph_model3_t* topicData
);

/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
xme_status_t
chromosomeGui_wp_demarshaler_init(void)
{
	XME_HAL_TABLE_INIT(configurationTable);

	return XME_STATUS_SUCCESS;
}

xme_status_t
chromosomeGui_wp_demarshaler_run
(
	xme_wp_waypoint_instanceId_t instanceId
)
{
	xme_status_t status;
	configurationItem_t* configurationItem;

	configurationItem = XME_HAL_TABLE_ITEM_FROM_HANDLE
	(
		configurationTable, 
		(xme_hal_table_rowHandle_t)instanceId
	);

	XME_CHECK
	(
		NULL != configurationItem,
		XME_STATUS_INVALID_HANDLE
	);
	
	// Do the marshaling for this configuration
	status = doDemarshaling
	(
		configurationItem->topic,	
		configurationItem->inputPort, 
		configurationItem->outputPort
	);

	XME_CHECK
	(
		XME_STATUS_SUCCESS == status, 
		XME_STATUS_INTERNAL_ERROR
	);

	return XME_STATUS_SUCCESS;
}

xme_status_t
chromosomeGui_wp_demarshaler_addConfig
(
	xme_wp_waypoint_instanceId_t* instanceId,
	xme_core_topic_t topic,
	xme_core_dataManager_dataPacketId_t inputPort,
	xme_core_dataManager_dataPacketId_t outputPort
)
{
	xme_hal_table_rowHandle_t configurationItemHandle;
	configurationItem_t* configurationItem;

	XME_CHECK
	(
		chromosomeGui_wp_demarshaler_isSupported(topic),
		XME_STATUS_INVALID_PARAMETER
	);

	configurationItemHandle = XME_HAL_TABLE_ADD_ITEM(configurationTable);

	XME_CHECK
	(
		XME_HAL_TABLE_INVALID_ROW_HANDLE != configurationItemHandle,
		XME_STATUS_OUT_OF_RESOURCES
	);

	configurationItem = XME_HAL_TABLE_ITEM_FROM_HANDLE
	(
		configurationTable, 
		configurationItemHandle
	);
	
	XME_ASSERT(NULL != configurationItem);

	configurationItem->topic = topic;
	configurationItem->inputPort = inputPort;
	configurationItem->outputPort = outputPort;

	// We use the row handle to identify this configuration
	*instanceId = (xme_wp_waypoint_instanceId_t)configurationItemHandle;

	return XME_STATUS_SUCCESS;
}

xme_status_t
chromosomeGui_wp_demarshaler_fini(void)
{
	XME_HAL_TABLE_FINI(configurationTable);

	return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshaling
(
	xme_core_topic_t topic,
	xme_core_dataManager_dataPacketId_t inputPort,
	xme_core_dataManager_dataPacketId_t outputPort
)
{
	void* buffer;
	unsigned int bufferSize;
	xme_status_t status;

	// Switch for the correct topic
	// In the respective cases we allocate a buffer with the right size for the topic and
	// call a function that performs the read from the inputPort and the actual demarshaling
	if (XME_CORE_TOPIC(CHROMOSOMEGUI_TOPIC_BUTTONSIGNAL) == topic)
	{
		chromosomeGui_topic_ButtonSignal_t topicData;
		
		buffer = &topicData;
		bufferSize = sizeof(chromosomeGui_topic_ButtonSignal_t);
		
		status = doDemarshalingForButtonSignal
		(
			inputPort,
			&topicData
		);
	}
	else if (XME_CORE_TOPIC(CHROMOSOMEGUI_TOPIC_WRITETEXT) == topic)
	{
		chromosomeGui_topic_WriteText_t topicData;
		
		buffer = &topicData;
		bufferSize = sizeof(chromosomeGui_topic_WriteText_t);
		
		status = doDemarshalingForWriteText
		(
			inputPort,
			&topicData
		);
	}
	else if (XME_CORE_TOPIC(XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL) == topic)
	{
		xme_core_topic_pnpManager_runtime_graph_model_t topicData;
		
		buffer = &topicData;
		bufferSize = sizeof(xme_core_topic_pnpManager_runtime_graph_model_t);
		
		status = doDemarshalingForPnpManager_runtime_graph_model
		(
			inputPort,
			&topicData
		);
	}
	else if (XME_CORE_TOPIC(XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL2) == topic)
	{
		xme_core_topic_pnpManager_runtime_graph_model2_t topicData;
		
		buffer = &topicData;
		bufferSize = sizeof(xme_core_topic_pnpManager_runtime_graph_model2_t);
		
		status = doDemarshalingForPnpManager_runtime_graph_model2
		(
			inputPort,
			&topicData
		);
	}
	else if (XME_CORE_TOPIC(XME_CORE_TOPIC_PNPMANAGER_RUNTIME_GRAPH_MODEL3) == topic)
	{
		xme_core_topic_pnpManager_runtime_graph_model3_t topicData;
		
		buffer = &topicData;
		bufferSize = sizeof(xme_core_topic_pnpManager_runtime_graph_model3_t);
		
		status = doDemarshalingForPnpManager_runtime_graph_model3
		(
			inputPort,
			&topicData
		);
	}
	else
	{
		XME_LOG
		(
			XME_LOG_ERROR, 
			"chromosomeGui_wp_demarshaler_run(): Given topic with id %" PRIu64 " is not "
			"supported by this demarshaler.",
			topic
		);
		return XME_STATUS_INTERNAL_ERROR;
	}

	XME_CHECK
	(
		XME_STATUS_SUCCESS == status,
		XME_STATUS_INTERNAL_ERROR
	);

	// Write marshaled data to outputPort
	status = xme_core_dataHandler_writeData
	(
		outputPort,
		buffer,
		bufferSize
	);

	XME_CHECK
	(
		XME_STATUS_SUCCESS == status,
		XME_STATUS_INTERNAL_ERROR
	);
	
	xme_core_dataHandler_completeWriteOperation(outputPort);
	xme_core_dataHandler_completeReadOperation(inputPort);

	return XME_STATUS_SUCCESS;
}

xme_status_t
doDemarshalingForButtonSignal
(
	xme_core_dataManager_dataPacketId_t inputPort,
	chromosomeGui_topic_ButtonSignal_t* topicData
)
{
	const uint32_t marshaledDataSize = 1;
	unsigned int bytesRead;
	uint8_t marshaledData[1];
	uint8_t* bufferPtr;
	xme_status_t status;
	
	bufferPtr = marshaledData;

	// Read marshaled topic data
	status = xme_core_dataHandler_readData
	(
		inputPort,
		bufferPtr,
		marshaledDataSize,
		&bytesRead
	);

	XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
	XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

	// Demarshal data
	
	// char topicData->buttonPushed
	{
		char hostValue;
		
		hostValue = (char)(*(uint8_t*)bufferPtr);
		topicData->buttonPushed = hostValue;
		bufferPtr += 1;
	}
	
	return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForWriteText
(
	xme_core_dataManager_dataPacketId_t inputPort,
	chromosomeGui_topic_WriteText_t* topicData
)
{
	const uint32_t marshaledDataSize = 1000;
	unsigned int bytesRead;
	uint8_t marshaledData[1000];
	uint8_t* bufferPtr;
	xme_status_t status;
	
	bufferPtr = marshaledData;

	// Read marshaled topic data
	status = xme_core_dataHandler_readData
	(
		inputPort,
		bufferPtr,
		marshaledDataSize,
		&bytesRead
	);

	XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
	XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

	// Demarshal data
	
	// char topicData->text
	{
		uint16_t i0;
		
		for (i0 = 0; i0 < 1000; i0++)
		{
			// char topicData->text
			{
				char hostValue;
				
				hostValue = (char)(*(uint8_t*)bufferPtr);
				topicData->text[i0] = hostValue;
				bufferPtr += 1;
			}
		}
	}
	
	return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForPnpManager_runtime_graph_model
(
	xme_core_dataManager_dataPacketId_t inputPort,
	xme_core_topic_pnpManager_runtime_graph_model_t* topicData
)
{
	const uint32_t marshaledDataSize = 2962;
	unsigned int bytesRead;
	uint8_t marshaledData[2962];
	uint8_t* bufferPtr;
	xme_status_t status;
	
	bufferPtr = marshaledData;

	// Read marshaled topic data
	status = xme_core_dataHandler_readData
	(
		inputPort,
		bufferPtr,
		marshaledDataSize,
		&bytesRead
	);

	XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
	XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

	// Demarshal data
	
	// uint16_t topicData->nodeId
	{
		int16_t hostValue;
		
		hostValue = (int16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
		topicData->nodeId = hostValue;
		bufferPtr += 2;
	}
	
	// struct topicData->vertex
	{
		uint8_t i0;
		
		for (i0 = 0; i0 < 10; i0++)
		{
			// struct topicData->vertex
			{
				// uint8_t topicData->vertex[i0].vertexType
				{
					int8_t hostValue;
					
					hostValue = (int8_t)(*(uint8_t*)bufferPtr);
					topicData->vertex[i0].vertexType = hostValue;
					bufferPtr += 1;
				}
				
				// char topicData->vertex[i0].vertexData
				{
					uint16_t i1;
					
					for (i1 = 0; i1 < 256; i1++)
					{
						// char topicData->vertex[i0].vertexData
						{
							char hostValue;
							
							hostValue = (char)(*(uint8_t*)bufferPtr);
							topicData->vertex[i0].vertexData[i1] = hostValue;
							bufferPtr += 1;
						}
					}
				}
				
				// uint32_t topicData->vertex[i0].instanceId
				{
					int32_t hostValue;
					
					hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
					topicData->vertex[i0].instanceId = hostValue;
					bufferPtr += 4;
				}
			}
		}
	}
	
	// struct topicData->edge
	{
		uint8_t i0;
		
		for (i0 = 0; i0 < 10; i0++)
		{
			// struct topicData->edge
			{
				// int8_t topicData->edge[i0].srcVertexIndex
				{
					uint8_t hostValue;
					
					hostValue = (uint8_t)(*(uint8_t*)bufferPtr);
					topicData->edge[i0].srcVertexIndex = hostValue;
					bufferPtr += 1;
				}
				
				// int8_t topicData->edge[i0].sinkVertexIndex
				{
					uint8_t hostValue;
					
					hostValue = (uint8_t)(*(uint8_t*)bufferPtr);
					topicData->edge[i0].sinkVertexIndex = hostValue;
					bufferPtr += 1;
				}
				
				// uint8_t topicData->edge[i0].edgeType
				{
					int8_t hostValue;
					
					hostValue = (int8_t)(*(uint8_t*)bufferPtr);
					topicData->edge[i0].edgeType = hostValue;
					bufferPtr += 1;
				}
				
				// char topicData->edge[i0].edgeData
				{
					uint8_t i1;
					
					for (i1 = 0; i1 < 32; i1++)
					{
						// char topicData->edge[i0].edgeData
						{
							char hostValue;
							
							hostValue = (char)(*(uint8_t*)bufferPtr);
							topicData->edge[i0].edgeData[i1] = hostValue;
							bufferPtr += 1;
						}
					}
				}
			}
		}
	}
	
	return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForPnpManager_runtime_graph_model2
(
	xme_core_dataManager_dataPacketId_t inputPort,
	xme_core_topic_pnpManager_runtime_graph_model2_t* topicData
)
{
	const uint32_t marshaledDataSize = 2962;
	unsigned int bytesRead;
	uint8_t marshaledData[2962];
	uint8_t* bufferPtr;
	xme_status_t status;
	
	bufferPtr = marshaledData;

	// Read marshaled topic data
	status = xme_core_dataHandler_readData
	(
		inputPort,
		bufferPtr,
		marshaledDataSize,
		&bytesRead
	);

	XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
	XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

	// Demarshal data
	
	// uint16_t topicData->nodeId
	{
		int16_t hostValue;
		
		hostValue = (int16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
		topicData->nodeId = hostValue;
		bufferPtr += 2;
	}
	
	// struct topicData->vertex
	{
		uint8_t i0;
		
		for (i0 = 0; i0 < 10; i0++)
		{
			// struct topicData->vertex
			{
				// uint8_t topicData->vertex[i0].vertexType
				{
					int8_t hostValue;
					
					hostValue = (int8_t)(*(uint8_t*)bufferPtr);
					topicData->vertex[i0].vertexType = hostValue;
					bufferPtr += 1;
				}
				
				// char topicData->vertex[i0].vertexData
				{
					uint16_t i1;
					
					for (i1 = 0; i1 < 256; i1++)
					{
						// char topicData->vertex[i0].vertexData
						{
							char hostValue;
							
							hostValue = (char)(*(uint8_t*)bufferPtr);
							topicData->vertex[i0].vertexData[i1] = hostValue;
							bufferPtr += 1;
						}
					}
				}
				
				// uint32_t topicData->vertex[i0].instanceId
				{
					int32_t hostValue;
					
					hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
					topicData->vertex[i0].instanceId = hostValue;
					bufferPtr += 4;
				}
			}
		}
	}
	
	// struct topicData->edge
	{
		uint8_t i0;
		
		for (i0 = 0; i0 < 10; i0++)
		{
			// struct topicData->edge
			{
				// int8_t topicData->edge[i0].srcVertexIndex
				{
					uint8_t hostValue;
					
					hostValue = (uint8_t)(*(uint8_t*)bufferPtr);
					topicData->edge[i0].srcVertexIndex = hostValue;
					bufferPtr += 1;
				}
				
				// int8_t topicData->edge[i0].sinkVertexIndex
				{
					uint8_t hostValue;
					
					hostValue = (uint8_t)(*(uint8_t*)bufferPtr);
					topicData->edge[i0].sinkVertexIndex = hostValue;
					bufferPtr += 1;
				}
				
				// uint8_t topicData->edge[i0].edgeType
				{
					int8_t hostValue;
					
					hostValue = (int8_t)(*(uint8_t*)bufferPtr);
					topicData->edge[i0].edgeType = hostValue;
					bufferPtr += 1;
				}
				
				// char topicData->edge[i0].edgeData
				{
					uint8_t i1;
					
					for (i1 = 0; i1 < 32; i1++)
					{
						// char topicData->edge[i0].edgeData
						{
							char hostValue;
							
							hostValue = (char)(*(uint8_t*)bufferPtr);
							topicData->edge[i0].edgeData[i1] = hostValue;
							bufferPtr += 1;
						}
					}
				}
			}
		}
	}
	
	return XME_STATUS_SUCCESS;
}
xme_status_t
doDemarshalingForPnpManager_runtime_graph_model3
(
	xme_core_dataManager_dataPacketId_t inputPort,
	xme_core_topic_pnpManager_runtime_graph_model3_t* topicData
)
{
	const uint32_t marshaledDataSize = 2962;
	unsigned int bytesRead;
	uint8_t marshaledData[2962];
	uint8_t* bufferPtr;
	xme_status_t status;
	
	bufferPtr = marshaledData;

	// Read marshaled topic data
	status = xme_core_dataHandler_readData
	(
		inputPort,
		bufferPtr,
		marshaledDataSize,
		&bytesRead
	);

	XME_CHECK(status == XME_STATUS_SUCCESS, XME_STATUS_INTERNAL_ERROR);
	XME_CHECK(bytesRead == marshaledDataSize, XME_STATUS_INTERNAL_ERROR);

	// Demarshal data
	
	// uint16_t topicData->nodeId
	{
		int16_t hostValue;
		
		hostValue = (int16_t)xme_hal_net_ntohs((*(uint16_t*)bufferPtr));
		topicData->nodeId = hostValue;
		bufferPtr += 2;
	}
	
	// struct topicData->vertex
	{
		uint8_t i0;
		
		for (i0 = 0; i0 < 10; i0++)
		{
			// struct topicData->vertex
			{
				// uint8_t topicData->vertex[i0].vertexType
				{
					int8_t hostValue;
					
					hostValue = (int8_t)(*(uint8_t*)bufferPtr);
					topicData->vertex[i0].vertexType = hostValue;
					bufferPtr += 1;
				}
				
				// char topicData->vertex[i0].vertexData
				{
					uint16_t i1;
					
					for (i1 = 0; i1 < 256; i1++)
					{
						// char topicData->vertex[i0].vertexData
						{
							char hostValue;
							
							hostValue = (char)(*(uint8_t*)bufferPtr);
							topicData->vertex[i0].vertexData[i1] = hostValue;
							bufferPtr += 1;
						}
					}
				}
				
				// uint32_t topicData->vertex[i0].instanceId
				{
					int32_t hostValue;
					
					hostValue = (int32_t)xme_hal_net_ntohl((*(uint32_t*)bufferPtr));
					topicData->vertex[i0].instanceId = hostValue;
					bufferPtr += 4;
				}
			}
		}
	}
	
	// struct topicData->edge
	{
		uint8_t i0;
		
		for (i0 = 0; i0 < 10; i0++)
		{
			// struct topicData->edge
			{
				// int8_t topicData->edge[i0].srcVertexIndex
				{
					uint8_t hostValue;
					
					hostValue = (uint8_t)(*(uint8_t*)bufferPtr);
					topicData->edge[i0].srcVertexIndex = hostValue;
					bufferPtr += 1;
				}
				
				// int8_t topicData->edge[i0].sinkVertexIndex
				{
					uint8_t hostValue;
					
					hostValue = (uint8_t)(*(uint8_t*)bufferPtr);
					topicData->edge[i0].sinkVertexIndex = hostValue;
					bufferPtr += 1;
				}
				
				// uint8_t topicData->edge[i0].edgeType
				{
					int8_t hostValue;
					
					hostValue = (int8_t)(*(uint8_t*)bufferPtr);
					topicData->edge[i0].edgeType = hostValue;
					bufferPtr += 1;
				}
				
				// char topicData->edge[i0].edgeData
				{
					uint8_t i1;
					
					for (i1 = 0; i1 < 32; i1++)
					{
						// char topicData->edge[i0].edgeData
						{
							char hostValue;
							
							hostValue = (char)(*(uint8_t*)bufferPtr);
							topicData->edge[i0].edgeData[i1] = hostValue;
							bufferPtr += 1;
						}
					}
				}
			}
		}
	}
	
	return XME_STATUS_SUCCESS;
}

bool
chromosomeGui_wp_demarshaler_isSupported
(
	xme_core_topic_t topic
)
{
	uint64_t i;
	size_t supportTopicsLength;
	
	supportTopicsLength = sizeof(supportedTopics) / sizeof(supportedTopics[0]);
	
	for (i = 0; i < supportTopicsLength; i++)
	{
		if (topic == supportedTopics[i])
		{
			return true;
		}
	}
	
	return false;
}
